{"name":"Provigen","tagline":"Generates content providers from annotated contract classes.","body":"# ProviGen\r\n\r\nEasily make a [ContentProvider] from a [ContractClass].    \r\n\r\n## Installation\r\n\r\n* Put the ProviGen [jar] in your `libs` folder or add ProviGen as a library project.\r\n\r\n[jar]: https://github.com/TimotheeJeannin/ProviGen/tree/master/ProviGenDownloads\r\n\r\n* Annotate your ContractClass.\r\n\r\n```java\r\n@Contract(version = 1)\r\npublic interface MyContract extends ProviGenBaseContract {\r\n\r\n\t@Column(Type.INTEGER)\r\n\tpublic static final String MY_INT_COLUMN = \"int\";\r\n\r\n\t@Column(Type.TEXT)\r\n\tpublic static final String MY_STRING_COLUMN = \"string\";\r\n\r\n\t@ContentUri\r\n\tpublic static final Uri CONTENT_URI = Uri.parse(\"content://com.myapp/table_name\");\r\n}\r\n```\r\n\r\n* Extend the ProviGenProvider.\r\n\r\n```java\r\npublic class MyContentProvider extends ProviGenProvider {\r\n\r\n\tpublic MyContentProvider() throws InvalidContractException {\r\n\t\tsuper(MyContract.class);\r\n\t}\r\n}\r\n```\r\n\r\n* Add your provider in your manifest.\r\n\r\n```xml\r\n<provider\r\n    android:name=\"com.myapp.MyContentProvider\"\r\n    android:authorities=\"com.myapp\" >\r\n</provider>\r\n```\r\n\r\n* You're done.\r\n\r\n## Usage\r\n\r\nYou can make the usual insert, update, delete and query using a [ContentResolver].    \r\nFor example querying a single row boils down to:\r\n```java\r\ngetContentResolver().query(\t\r\n\tUri.withAppendedPath(MyContract.CONTENT_URI, myId),\r\n\tnull, \"\", null, \"\");\r\n```\r\nor \r\n```java\r\ngetContentResolver().query(\r\n\tMyContract.CONTENT_URI, null, \r\n\tMyContract._ID + \" = ? \", new String[]{ myId }, \"\");\r\n```\r\n\r\n## Features\r\n\r\n### Multiple contact classes\r\n\r\nYou can use ProviGen with several [ContractClass] just by passing an array of contract classes to the ProviGenProvider constructor.\r\n```java\r\npublic class MyContentProvider extends ProviGenProvider {\r\n\r\n\tpublic MyContentProvider() throws InvalidContractException {\r\n\t\tsuper(new Class[] { FirstContract.class, SecondContract.class });\r\n\t}\r\n}\r\n```\r\nProviGen will create a table for each contract class.     \r\nThe table name will be the last path segment of the contract's content uri.\r\n\r\n### Notifications and observers\r\n\r\nProviGen fully supports the uri notification mechanism.   \r\nYou can safely use it with [CursorLoader]s and [ContentObserver]s.\r\n\r\n### Initial population\r\n\r\nProviGen will automatically create the needed table for you.    \r\nInitial population can be done overriding the `onCreateDatabase` method.\r\n```java\r\npublic class MyContentProvider extends ProviGenProvider {\r\n\r\n\tpublic MyContentProvider() throws InvalidContractException {\r\n\t\tsuper(MyContract.class);\r\n\t}\r\n\r\n\t@Override\r\n\tpublic void onCreateDatabase(SQLiteDatabase database) {\r\n\t\t// Automatically creates table and needed columns.\r\n\t\tsuper.onCreateDatabase(database); \r\n\r\n\t\t// If needed, populate table here.\r\n\t}\r\n}\r\n```\r\nIf you want to create the table yourself, just don't call `super.onCreateDatabase(database)`.\r\n\r\n### Contract upgrades\r\n\r\nIf you increase the version of a contract class, ProviGen will automatically add missing columns for you.    \r\nAny other changes should be done overriding the `onUpgradeDatabase` method.\r\n```java\r\npublic class MyContentProvider extends ProviGenProvider {\r\n\r\n\tpublic MyContentProvider() throws InvalidContractException {\r\n\t\tsuper(MyContract.class);\r\n\t}\r\n\r\n\t@Override\r\n\tpublic void onUpgradeDatabase(SQLiteDatabase database, int oldVersion, int newVersion) {\r\n\t\t// Automatically adds new columns.\r\n\t\tsuper.onUpgradeDatabase(database, oldVersion, newVersion);\r\n\r\n\t\t// Anything else related to database upgrade should be done here. \r\n\t}\r\n}\r\n```\r\nIf you want to add missing columns yourself, just don't call `super.onUpgradeDatabase(database, oldVersion, newVersion)`\r\n\r\n### Data constraint\r\n\r\nYou can apply a `UNIQUE` constraint to a column using the `@Unique` annotation.\r\n\r\n```java\r\n@Unique(OnConflict.REPLACE)\r\n@Column(Type.INTEGER)\r\npublic static final String MY_INT = \"my_int\";\r\n```\r\n\r\nYou can apply a `NOT_NULL` constraint to a column using the `@NotNull` annotation.\r\n\r\n```java\r\n@NotNull(OnConflict.ABORT)\r\n@Column(Type.INTEGER)\r\npublic static final String MY_INT = \"my_int\";\r\n```\r\n\r\n`CHECK` constraint is not supported yet.\r\n\r\n## License\r\n\r\nThis content is released under the MIT License.\r\n\r\n[ContentObserver]: https://developer.android.com/reference/android/database/ContentObserver.html\r\n\r\n[CursorLoader]: http://developer.android.com/reference/android/content/CursorLoader.html\r\n\r\n[ContentProvider]: https://developer.android.com/reference/android/content/ContentProvider.html\r\n\r\n[ContractClass]: http://developer.android.com/guide/topics/providers/content-provider-basics.html#ContractClasses\r\n\r\n[ContentResolver]: https://developer.android.com/reference/android/content/ContentResolver.html\r\n","google":"UA-47830197-1","note":"Don't delete this file! It's used internally to help with page regeneration."}